# Computation of the orbit model for RAR + barionic component (maybe also the best fit potential
#  Malhan+19), 
# using Malhan+19 data.
# Optimization to find best fit orbit.

from astropy import units as u
from astropy.coordinates import SkyCoord
import astropy.coordinates as coord
from scipy.integrate import solve_ivp
from astropy.io import ascii
from scipy import optimize
from scipy import interpolate
import numpy as np
import scipy.integrate as integrate
from scipy.interpolate import InterpolatedUnivariateSpline
from scipy.interpolate import interp1d
import matplotlib.pyplot as plt
import config as cfg
import accelerations_combine as acco
import GD1Koposov10_class as GD1_class
import model_def
import pandas as pd
from astroquery.gaia import Gaia

# Rar model evaluation
ener_f = 56.0  # keV
param = np.array([ener_f, 3.77780827e+01, 6.63468885e+01, 1.20446329e-05])  # 
r_mw,mass_mw = model_def.model(param)
rho_mw = np.diff(mass_mw)/np.diff(r_mw)/(4.0*np.pi*r_mw[:-1]**2)  # M_sun/pc^3

# Interpolation avoiding NANs
k = np.argwhere(np.isnan(mass_mw))[0][0]
r_sh = r_mw[0:k]
mass_sh = mass_mw[0:k]
cfg.r_max_mw=r_sh[-1]

cfg.mass_spline = InterpolatedUnivariateSpline(r_sh,mass_sh,k=4)  # Allows easy computation of derivatives
def rho_spline(r) :
    deriv= mass_spline.derivative(1)
    return deriv(r)/(4.0*np.pi*r*r)


# In[ ]:


# Gradient generated by MW's halo
def symp_grad_mw(t, w):
    x=w[0]
    y=w[1]
    z=w[2]
    px=w[3]
    py=w[4]
    pz=w[5]
    r=np.sqrt(x*x+y*y+z*z)
    #print('time=',t)
    return [px,py,pz, acco.accel_mw(x,y,z)[0], acco.accel_mw(x,y,z)[1], acco.accel_mw(x,y,z)[2]]

def grad_mw(x,y,z):
    return -acco.accel_mw(x,y,z)

def rot_vel_mw(r):
    return np.sqrt(r*(grad_mw(r,0,0)[0]))

# Orbit definition
# The orbit_model here defined works with sky coordinates at input and sky-cartesian at output
def orbit_model(alpha,delta,distance,mu_alpha,mu_delta,v_los):
#    print('param= ',alpha,delta,distance,mu_alpha,mu_delta,v_los)
    
    # Transformation to galactocentric coordinates
    sky_coord = coord.ICRS(ra=alpha*u.degree, dec=delta*u.degree,
                distance=distance*u.kpc,
                pm_ra_cosdec=mu_alpha*np.cos(delta*u.degree)*u.mas/u.yr,
                pm_dec=mu_delta*u.mas/u.yr,
                radial_velocity=v_los*u.km/u.s)
    galcen_distance = r_sun*u.kpc
    v_sun = coord.CartesianDifferential([11.1, v_circ_sun+12.24, 7.25]*u.km/u.s)
    z_sun=0.0*u.kpc
    frame = coord.Galactocentric(galcen_distance=galcen_distance,
                                galcen_v_sun=v_sun,
                                z_sun=z_sun)
    galac_coord= sky_coord.transform_to(frame)
    
    w_0 = np.zeros(6)
    w_0[:3]=[galac_coord.x/u.kpc,galac_coord.y/u.kpc,galac_coord.z/u.kpc]
    w_0[3:]=[galac_coord.v_x/(u.km/u.s),galac_coord.v_y/(u.km/u.s),galac_coord.v_z/(u.km/u.s)]

    
    # ODE integration
    unit_t = 0.977792221680356   # Gyr
    time_span_s2 = 0.2/unit_t #
    t_0=0.0/unit_t    
    n_steps = 1000
    t_back = np.linspace(t_0,-time_span_s2, n_steps+1)
    t_forw = np.linspace(t_0,time_span_s2, n_steps+1)       
    sol_back = solve_ivp(symp_grad_mw, [t_0,-time_span_s2], w_0, t_eval=t_back,method='DOP853',rtol=5.0e-14,atol=0.5e-14)
    sol_forw = solve_ivp(symp_grad_mw, [t_0,time_span_s2], w_0, t_eval=t_forw,method='DOP853',rtol=5.0e-14,atol=0.5e-14)
    
    t = np.concatenate([sol_back.t,sol_forw.t])
    y = np.concatenate([sol_back.y, sol_forw.y],axis=1)
    y = np.delete(y,0,axis=1) #Remove duplicated column
    
    #Transformation to GD-1 frame of coordinates (\phi_1, \phi_2)
    galac_coord=coord.Galactocentric(x=y[0]*u.kpc,y=y[1]*u.kpc,z=y[2]*u.kpc,
                                     v_x=y[3]*u.km/u.s,v_y=y[4]*u.km/u.s,v_z=y[5]*u.km/u.s,
                           galcen_distance=galcen_distance,galcen_v_sun=v_sun,z_sun=z_sun) 
    gd1_coord = galac_coord.transform_to(GD1_class.GD1Koposov10)
    phi_1 = gd1_coord.phi1
    phi_2 = gd1_coord.phi2
    d_hel = gd1_coord.distance
    v_hel = gd1_coord.radial_velocity
    mu_phi_1 = gd1_coord.pm_phi1_cosphi2/np.cos(phi_2)  #not used by Ibata
    mu_phi_2 = gd1_coord.pm_phi2
    #return phi_1, phi_2, d_hel, v_hel, mu_phi_1, mu_phi_2
    # Transformation to ICRS coordinates      
    icrs_coord=galac_coord.transform_to(coord.ICRS)
    mu_ra = icrs_coord.pm_ra_cosdec / np.cos(icrs_coord.dec)
    mu_dec= icrs_coord.pm_dec
    return phi_1, phi_2, d_hel, mu_ra, mu_dec, v_hel, y[0], y[1], y[2]


# In[24]:


# Ibata's polynomials.
# [x] = radians
# [S] = radians
# [D] = kpc
# [V] = km/s                                                              
# [MU] = mas/year
class IbaPoly:
    def S(self,x):
        return 0.008367*x**3-0.05332*x**2-0.07739*x-0.02007
    def D(self,x):
        return -4.302*x**5-11.54*x**4-7.161*x**3+5.985*x**2+8.595*x+10.36
    def V(self,x):
        return 90.68*x**3+204.5*x**2-254.2*x-261.5
    def MU_RA(self,x):
        return 3.794*x**3+9.467*x**2+1.615*x-7.844
    def MU_DEC(self,x):
        return -1.225*x**3+8.313*x**2+18.68*x-3.95
    limit = [-90,10]

pol = IbaPoly()
print('valor=',pol.S(np.linspace(-90,10,10)))

# Observations (Ibata polynomials evaluated in a grid)
Iba_sky = pd.DataFrame()
Iba_sky['phi_1'] = np.linspace(IbaPoly.limit[0],IbaPoly.limit[1],100)
Iba_sky['phi_2'] = pol.S(cfg.deg2rad*Iba_sky['phi_1'])/cfg.deg2rad
Iba_sky['d_hel'] = pol.D(cfg.deg2rad*Iba_sky['phi_1'])
Iba_sky['v_hel'] = pol.V(cfg.deg2rad*Iba_sky['phi_1'])
Iba_sky['mu_ra'] = pol.MU_RA(cfg.deg2rad*Iba_sky['phi_1'])
Iba_sky['mu_dec'] = pol.MU_DEC(cfg.deg2rad*Iba_sky['phi_1'])

def invert_ic(u_0):
    w_0=u_0
    gd1_coord = GD1_class.GD1Koposov10(phi1=u_0[0]*u.degree, phi2=u_0[1]*u.degree)
    icrs_coord = gd1_coord.transform_to(coord.ICRS)
    w_0[0]=icrs_coord.ra.value
    w_0[1]=icrs_coord.dec.value
    return w_0   

#print('To compare with the Figures in Malhan+19')
[Iba_sky['RA'],Iba_sky['Dec']] = invert_ic([Iba_sky['phi_1'],Iba_sky['phi_2']])


# Load Malhan+19 tables
"""
Uncomment to download data from Gaia for the first time. 
Otherwise just open the file at the bottom of this cell.

data = cross_match('asu.tsv')
"""

# Open cross matched file
from astropy.table import Table
data = Table.read('cross_matched.dat', format='ascii')
print(type(data))
print(len(data))

arr = data['Pmember']
boolarr=  (arr=='Y')

data = data[boolarr]
print(type(data))
print(len(data))



# Chi^2 function
def chi2(w_0):
	import wrap_ra as wrap
    
	phi_1, phi_2, d_hel, mu_ra, mu_dec, v_hel, x,y,z = orbit_model(w_0[0],w_0[1],w_0[2],w_0[3],w_0[4],w_0[5]) 
    
	[ra,dec] = invert_ic([phi_1.value,phi_2.value])
	cfg.dec_spl = interp1d(ra,dec,kind='cubic')
	cfg.v_hel_spl = interp1d(ra,v_hel,kind='cubic')
	cfg.mu_ra_spl  = interp1d(ra,mu_ra,kind='cubic')
	cfg.mu_dec_spl  = interp1d(ra,mu_dec,kind='cubic')
    	
	cfg.ra_min = np.amin(ra)
	cfg.ra_max = np.amax(ra)
  
	sum=np.zeros(4)
	y_mod = wrap.dec_wrap(data['RAJ2000'])
	y_dat = data['DEJ2000']
	sigma2 = 0.1**2
	sum[0] = np.sum( (y_dat-y_mod)**2 / sigma2 )
	
	y_mod = wrap.mu_ra_wrap(data['RAJ2000'])
	y_dat = data['pmra']
	sigma2 = data['pmra_error']**2
	sum[1] = np.sum( (y_dat-y_mod)**2 / sigma2 )
	
	y_mod = wrap.mu_dec_wrap(data['RAJ2000'])
	y_dat = data['pmdec']
	sigma2 = data['pmdec_error']**2
	sum[2] = np.sum( (y_dat-y_mod)**2 / sigma2 )
    
	y_mod = wrap.v_hel_wrap(data['RAJ2000'])
	y_dat = data['Vlos']
	sigma2 = data['e_Vlos']**2
	sum[3] = np.sum( (y_dat-y_mod)**2 / sigma2 )
	
	print('chi^2 =',np.sum(sum))
	return np.sum(sum)


# Optimization
#----------------
r_sun = 8.129
v_circ_sun=rot_vel_mw(r_sun)
print('v_circ(r_sun)=',v_circ_sun)

k0=50
u_0=np.array([Iba_sky['phi_1'][k0],Iba_sky['phi_2'][k0],Iba_sky['d_hel'][k0],
              Iba_sky['mu_ra'][k0],Iba_sky['mu_dec'][k0],Iba_sky['v_hel'][k0]])
w_0 = invert_ic(u_0)
print('We used seed: w_0=',w_0)
#w_0=np.array([157.6,43.717, 8.25, -6.53 ,-11.0 , -90.0]) 
#w_0=np.array([154.43815737978053, 41.352611518783334, 9.127975838807465, -6.135527680412597, -9.275558167001593, -63.00000001]) 
#w_0=np.array([1.559367262212365404e+02,4.244852938178294721e+01,7.808891728113153796e+00,-8.257404940737194110e+00,-1.118645915891409359e+01,-6.129407632055352195e+01])
dw = np.abs(w_0)*0.5
bounds=((w_0[0]-dw[0],w_0[0]+dw[0]), (w_0[1]-dw[1],w_0[1]+dw[1]), (w_0[2]-dw[2],w_0[2]+dw[2]),
        (w_0[3]-dw[3],w_0[3]+dw[3]), (w_0[4]-dw[4],w_0[4]+dw[4]), (w_0[5]-dw[5],w_0[5]+dw[5]))
#bounds =((130,170),(20,60),(4,12),(-20,0),(-20,0),(-70,-20) )

#opt=optimize.differential_evolution(chi2, bounds,strategy='best1bin',maxiter=30,popsize=30,tol=5.0e-8,atol=0.5e-8,disp=True,polish=True,workers=-1)
#param_fitted = opt.x
#np.savetxt('param_fit_data_MalhanGaiaDR2_to_RARbarions.txt', param_fitted, delimiter=',')  


# Test call:
#w_0 =np.loadtxt('param_fit_Ibata.txt')
#w_0=param_fitted
#w_0=[1.503499419144439742e+02,3.671310321536615362e+01,8.315653523998493668e+00,-6.390434697724216129e+00,-1.106768595825563040e+01,-2.396566624782315813e+01]
#w_0=[1.483505022805658200e+02,3.561237990411034104e+01,8.248438093508470459e+00,-5.809853982827676511e+00,-1.099350513610843905e+01,-1.490007571136384001e+01]
#w_0=[1.450721939742419693e+02,3.164375466558459138e+01,8.623984402476732924e+00,-6.550247395688575835e+00,-1.279246848554608107e+01,-3.095803810956167368e+01]
#w_0=[1.491370985649168972e+02,3.646514234347051797e+01,8.284471924981501090e+00,-5.952349861078442217e+00,-1.088003692038217096e+01,-1.885021289722358162e+01]
#w_0=[1.493370985649162890e+02,3.667599798207655226e+01,8.281589084285746694e+00,-6.017245723518942491e+00,-1.088799601035909781e+01,-2.369380131502371611e+01]
w_0=[1.441603914093074934e+02,3.062716314757697944e+01,7.491233989471653310e+00,-5.464739482020274153e+00,-1.175542071014499435e+01,-2.381729288669687605e+01]

print("w_0=",w_0)
phi_1,phi_2,d_hel,mu_ra,mu_dec,v_hel,x,y,z = orbit_model(w_0[0],w_0[1],w_0[2],w_0[3],w_0[4],w_0[5]) 
[ra,dec] = invert_ic([phi_1.value,phi_2.value])
chi2(w_0)

# Plot in galactocentric coordinates
#------------------------------------
fig=plt.figure(figsize=(10,10))

plt.scatter(x,y,s=0.1,marker='o',color='red')
plt.scatter(x,z,s=0.1,marker='o',color='blue')
plt.xlim(-15,10)
plt.ylim(-15,20)
plt.grid()
plt.legend()
plt.tight_layout()
#plt.show()
fig.savefig("plots/orbit_xyz_fit_my_w0_Malhan2RARbarionic.png")


# Plots in the sky using the GD-1 frame
#---------------------------------------
fig, (ax1,ax2,ax3,ax4,ax5) = plt.subplots(5, 1, sharex=True, figsize=(7,35))


# Sky position
ax1.set_title('Ibata+20 data with RAR and barions')
ax1.scatter(phi_1.wrap_at(180*u.deg),phi_2,s=0.1,marker='o', color='red')
ax1.plot(Iba_sky['phi_1'], Iba_sky['phi_2'], color='blue', label='Stream\n(Ibata+2020)')
ax1.set_ylim(-4,2)
ax1.set_ylabel(r'$\phi_2$ [degrees]')


# heliocentric radial velocity 
ax2.scatter(phi_1.wrap_at(180*u.deg),v_hel,s=0.1,marker='o', color='red')
ax2.plot(Iba_sky['phi_1'], Iba_sky['v_hel'], color='blue', label='Stream\n(Ibata+2020)')
ax2.set_ylim(-300,300)
ax2.set_ylabel(r'$v_{\rm{LOS}}$ [km s$^{-1}$]')

# heliocentric distance
ax3.scatter(phi_1,d_hel,s=0.1,marker='o', color='red')
ax3.plot(Iba_sky['phi_1'], Iba_sky['d_hel'], color='blue', label='Stream\n(Ibata+2020)')
ax3.set_ylim(7,12)
ax3.set_ylabel(r'$D$ [kpc]')

# proper motion along RA 
ax4.scatter(phi_1,mu_ra,s=0.5, color='red')
ax4.plot(Iba_sky['phi_1'], Iba_sky['mu_ra'], color='blue', label='Stream\n(Ibata+2020)')
ax4.set_ylabel(r'$\mu_\alpha$ [mas yr$^{-1}$]')
ax4.legend()

# proper motion along DEC
ax5.scatter(phi_1,mu_dec,s=0.5, color='red')
ax5.plot(Iba_sky['phi_1'], Iba_sky['mu_dec'], color='blue', label='Stream\n(Ibata+2020)')
ax5.set_ylabel(r'$\mu_\delta$ [mas yr$^{-1}$]')
ax5.legend()

plt.xlabel(r'$\phi_1$ [degrees]')
plt.xlim(IbaPoly.limit[0],IbaPoly.limit[1])
plt.tight_layout()
#plt.show()
fig.savefig("plots/sky_fit_Malhan2RARbarionicPolys.png")

# Plots using RA
fig, (ax1,ax2,ax3) = plt.subplots(3, 1, sharex=True, figsize=(13,15))

# proper motion along RA 
ax1.scatter(ra,mu_ra,s=0.5,color='red')
ax1.scatter(ra,mu_dec,s=0.5,color='orange')
ax1.plot(Iba_sky['RA'], Iba_sky['mu_ra'], color='blue', label=r'$\mu_\alpha$(Malhan+19)')
ax1.plot(Iba_sky['RA'], Iba_sky['mu_dec'], color='orange', label=r'$\mu_\delta$(Malhan+19)')
ax1.errorbar(data['RAJ2000'],data['pmra'],yerr=data['pmra_error'],fmt='o',color='black')
ax1.errorbar(data['RAJ2000'],data['pmdec'],yerr=data['pmdec_error'],fmt='o',color='black')
ax1.set_ylabel(r'$\mu$ [mas yr$^{-1}$]')
ax1.set_ylim(-15,5)
ax1.legend()

# heliocentric radial velocity 
ax2.scatter(ra,v_hel,s=0.5,color='red')
ax2.plot(Iba_sky['RA'], Iba_sky['v_hel'], color='blue', label='Ibata+19')
ax2.errorbar(data['RAJ2000'],data['Vlos'],yerr=data['e_Vlos'],fmt='o',color='black')
ax2.set_ylim(-300,300)
ax2.set_ylabel(r'$v_{\rm{LOS}}$ [km s$^{-1}$]')
ax2.set_xlim(130,230)

# sky position 
ax3.scatter(ra,dec,s=0.5,color='red')
ax3.plot(Iba_sky['RA'], Iba_sky['Dec'], color='blue', label='Ibata+19')
ax3.scatter(data['RAJ2000'],data['DEJ2000'])
ax3.set_ylim(10,70)
ax3.set_ylabel(r'$\delta$ [degrees]')
ax3.set_xlim(130,230)

plt.xlabel('RA [degrees]')
plt.xlim(130,230)
plt.tight_layout()
#plt.show()
fig.savefig("plots/sky_fit_Malhan2RARbarionic.png")





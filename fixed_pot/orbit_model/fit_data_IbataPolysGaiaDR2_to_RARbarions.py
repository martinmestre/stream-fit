# Computation of the orbit model for RAR + barionic component,
# using Ibata+20 polinomial data-fits.
# Optimization to find best fit orbit.

from astropy import units as u
from astropy.coordinates import SkyCoord
import astropy.coordinates as coord
from scipy.integrate import solve_ivp
from astropy.io import ascii
from scipy import optimize
from scipy import interpolate
import numpy as np
import scipy.integrate as integrate
from scipy.interpolate import InterpolatedUnivariateSpline
from scipy.interpolate import interp1d
import matplotlib.pyplot as plt
import config as cfg
import accelerations_combine as acco
import GD1Koposov10_class as GD1_class
import model_def
import pandas as pd


# Rar model evaluation
ener_f = 56.0  # keV
param = np.array([ener_f, 3.77780827e+01, 6.63468885e+01, 1.20446329e-05])  #
r_mw,mass_mw, nu = model_def.model(param)
rho_mw = np.diff(mass_mw)/np.diff(r_mw)/(4.0*np.pi*r_mw[:-1]**2)  # M_sun/pc^3

# Interpolation avoiding NANs
isnan = np.argwhere(np.isnan(mass_mw))
if (np.any(isnan)):
    k = isnan[0][0]
else:
    k = -1
    r_sh = r_mw[0:k]
    mass_sh = mass_mw[0:k]
cfg.r_max_mw = r_sh[-1]

cfg.mass_spline = InterpolatedUnivariateSpline(r_sh,mass_sh,k=4)  # Allows easy computation of derivatives
def rho_spline(r) :
    deriv= mass_spline.derivative(1)
    return deriv(r)/(4.0*np.pi*r*r)


# Gradient generated by MW's halo
def symp_grad_mw(t, w):
    x=w[0]
    y=w[1]
    z=w[2]
    px=w[3]
    py=w[4]
    pz=w[5]
    r=np.sqrt(x*x+y*y+z*z)
    #print('time=',t)
    return [px,py,pz, acco.accel_mw(x,y,z)[0], acco.accel_mw(x,y,z)[1], acco.accel_mw(x,y,z)[2]]

def grad_mw(x,y,z):
    return -acco.accel_mw(x,y,z)

def rot_vel_mw(r):
    return np.sqrt(r*(grad_mw(r,0,0)[0]))


# Orbit definition
# The orbit_model here defined works with sky coordinates at input and sky-cartesian at output
def orbit_model(alpha,delta,distance,mu_alpha,mu_delta,v_los):
#    print('param= ',alpha,delta,distance,mu_alpha,mu_delta,v_los)

    # Transformation to galactocentric coordinates
    sky_coord = coord.ICRS(ra=alpha*u.degree, dec=delta*u.degree,
                distance=distance*u.kpc,
                pm_ra_cosdec=mu_alpha*np.cos(delta*u.degree)*u.mas/u.yr,
                pm_dec=mu_delta*u.mas/u.yr,
                radial_velocity=v_los*u.km/u.s)
    galcen_distance = r_sun*u.kpc
    v_sun = coord.CartesianDifferential([11.1, v_circ_sun+12.24, 7.25]*u.km/u.s)
    z_sun=0.0*u.kpc
    frame = coord.Galactocentric(galcen_distance=galcen_distance,
                                galcen_v_sun=v_sun,
                                z_sun=z_sun)
    galac_coord= sky_coord.transform_to(frame)

    w_0 = np.zeros(6)
    w_0[:3]=[galac_coord.x/u.kpc,galac_coord.y/u.kpc,galac_coord.z/u.kpc]
    w_0[3:]=[galac_coord.v_x/(u.km/u.s),galac_coord.v_y/(u.km/u.s),galac_coord.v_z/(u.km/u.s)]


    # ODE integration
    unit_t = 0.977792221680356   # Gyr
    time_span_s2 = 0.2/unit_t #
    t_0=0.0/unit_t
    n_steps = 1000
    t_back = np.linspace(t_0,-time_span_s2, n_steps+1)
    t_forw = np.linspace(t_0,time_span_s2, n_steps+1)
    sol_back = solve_ivp(symp_grad_mw, [t_0,-time_span_s2], w_0, t_eval=t_back,method='DOP853',rtol=5.0e-14,atol=0.5e-14)
    sol_forw = solve_ivp(symp_grad_mw, [t_0,time_span_s2], w_0, t_eval=t_forw,method='DOP853',rtol=5.0e-14,atol=0.5e-14)

    t = np.concatenate([sol_back.t,sol_forw.t])
    y = np.concatenate([sol_back.y, sol_forw.y],axis=1)
    y = np.delete(y,0,axis=1) #Remove duplicated column

    #Transformation to GD-1 frame of coordinates (\phi_1, \phi_2)
    galac_coord=coord.Galactocentric(x=y[0]*u.kpc,y=y[1]*u.kpc,z=y[2]*u.kpc,
                                     v_x=y[3]*u.km/u.s,v_y=y[4]*u.km/u.s,v_z=y[5]*u.km/u.s,
                           galcen_distance=galcen_distance,galcen_v_sun=v_sun,z_sun=z_sun)
    gd1_coord = galac_coord.transform_to(GD1_class.GD1Koposov10)
    phi_1 = gd1_coord.phi1
    phi_2 = gd1_coord.phi2
    d_hel = gd1_coord.distance
    v_hel = gd1_coord.radial_velocity
    mu_phi_1 = gd1_coord.pm_phi1_cosphi2/np.cos(phi_2)  #not used by Ibata
    mu_phi_2 = gd1_coord.pm_phi2
    #return phi_1, phi_2, d_hel, v_hel, mu_phi_1, mu_phi_2
    # Transformation to ICRS coordinates
    icrs_coord=galac_coord.transform_to(coord.ICRS)
    mu_ra = icrs_coord.pm_ra_cosdec / np.cos(icrs_coord.dec)
    mu_dec= icrs_coord.pm_dec
    return phi_1, phi_2, d_hel, mu_ra, mu_dec, v_hel, y[0], y[1], y[2]




# Ibata's polynomials.
# [x] = radians
# [S] = radians
# [D] = kpc
# [V] = km/s
# [MU] = mas/year
class IbaPoly:
    def S(self,x):
        return 0.008367*x**3-0.05332*x**2-0.07739*x-0.02007
    def D(self,x):
        return -4.302*x**5-11.54*x**4-7.161*x**3+5.985*x**2+8.595*x+10.36
    def V(self,x):
        return 90.68*x**3+204.5*x**2-254.2*x-261.5
    def MU_RA(self,x):
        return 3.794*x**3+9.467*x**2+1.615*x-7.844
    def MU_DEC(self,x):
        return -1.225*x**3+8.313*x**2+18.68*x-3.95
    limit = [-90,10]

pol = IbaPoly()
print('valor=',pol.S(np.linspace(-90,10,10)))

# Observations (Ibata polynomials evaluated in a grid)
Iba_sky = pd.DataFrame()
Iba_sky['phi_1'] = np.linspace(IbaPoly.limit[0],IbaPoly.limit[1],100)
Iba_sky['phi_2'] = pol.S(cfg.deg2rad*Iba_sky['phi_1'])/cfg.deg2rad
Iba_sky['d_hel'] = pol.D(cfg.deg2rad*Iba_sky['phi_1'])
Iba_sky['v_hel'] = pol.V(cfg.deg2rad*Iba_sky['phi_1'])
Iba_sky['mu_ra'] = pol.MU_RA(cfg.deg2rad*Iba_sky['phi_1'])
Iba_sky['mu_dec'] = pol.MU_DEC(cfg.deg2rad*Iba_sky['phi_1'])


# Chi^2 function
def chi2(w_0):
    import wrap

    phi_1, phi_2, d_hel, mu_ra, mu_dec, v_hel, x,y,z = orbit_model(w_0[0],w_0[1],w_0[2],w_0[3],w_0[4],w_0[5])
    cfg.phi_2_spl = interp1d(phi_1,phi_2,kind='cubic')
    cfg.d_hel_spl = interp1d(phi_1,d_hel,kind='cubic')
    cfg.v_hel_spl = interp1d(phi_1,v_hel,kind='cubic')
    cfg.mu_ra_spl  = interp1d(phi_1,mu_ra,kind='cubic')
    cfg.mu_dec_spl  = interp1d(phi_1,mu_dec,kind='cubic')

    cfg.phi_1_min = np.amin(phi_1.value)
    cfg.phi_1_max = np.amax(phi_1.value)


    sum=np.zeros(5)

    y_mod = wrap.phi_2_wrap(Iba_sky['phi_1'])
    y_dat = Iba_sky['phi_2']
    sigma2 = 1.0
    sum[0] = np.sum( (y_dat-y_mod)**2 / sigma2 )

    y_mod = wrap.d_hel_wrap(Iba_sky['phi_1'])
    y_dat = Iba_sky['d_hel']
    sigma2 = 1.0
    sum[1] = np.sum( (y_dat-y_mod)**2 / sigma2 )

    y_mod = wrap.v_hel_wrap(Iba_sky['phi_1'])
    y_dat = Iba_sky['v_hel']
    sigma2 = 100.0
    sum[2] = np.sum( (y_dat-y_mod)**2 / sigma2 )

    y_mod = wrap.mu_ra_wrap(Iba_sky['phi_1'])
    y_dat = Iba_sky['mu_ra']
    sigma2 = 1.0
    sum[3] = np.sum( (y_dat-y_mod)**2 / sigma2 )

    y_mod = wrap.mu_dec_wrap(Iba_sky['phi_1'])
    y_dat = Iba_sky['mu_dec']
    sigma2 = 1.0
    sum[4] = np.sum( (y_dat-y_mod)**2 / sigma2 )

    print('chi^2 =',np.sum(sum))
    return np.sum(sum)


# Optimization
#----------------
def invert_ic(u_0):
    w_0=u_0
    gd1_coord = GD1_class.GD1Koposov10(phi1=u_0[0]*u.degree, phi2=u_0[1]*u.degree)
    icrs_coord = gd1_coord.transform_to(coord.ICRS)
    w_0[0]=icrs_coord.ra.value
    w_0[1]=icrs_coord.dec.value
    print(icrs_coord)
    return w_0

k0=50
u_0=np.array([Iba_sky['phi_1'][k0],Iba_sky['phi_2'][k0],Iba_sky['d_hel'][k0],
              Iba_sky['mu_ra'][k0],Iba_sky['mu_dec'][k0],Iba_sky['v_hel'][k0]])
w_0 = invert_ic(u_0)

#w_0=np.array([157.6,43.717, 8.25, -6.53 ,-11.0 , -90.0])
#w_0=np.array([154.43815737978053, 41.352611518783334, 9.127975838807465, -6.135527680412597, -9.275558167001593, -63.00000001])
#w_0=np.array([1.559367262212365404e+02,4.244852938178294721e+01,7.808891728113153796e+00,-8.257404940737194110e+00,-1.118645915891409359e+01,-6.129407632055352195e+01])
dw = np.abs(w_0)*0.5
bounds=((w_0[0]-dw[0],w_0[0]+dw[0]), (w_0[1]-dw[1],w_0[1]+dw[1]), (w_0[2]-dw[2],w_0[2]+dw[2]),
        (w_0[3]-dw[3],w_0[3]+dw[3]), (w_0[4]-dw[4],w_0[4]+dw[4]), (w_0[5]-dw[5],w_0[5]+dw[5]))
bounds =((100,300),(0,90),(4,15),(-50,50),(-50,50),(-300,300) )

r_sun = 8.129
v_circ_sun=rot_vel_mw(r_sun)
print('v_circ(r_sun)=',v_circ_sun)

# opt=optimize.differential_evolution(chi2, bounds,strategy='best1bin',maxiter=30,popsize=30,tol=5.0e-8,atol=0.5e-8,disp=True,polish=True,workers=-1)

# param_fitted = opt.x

# np.savetxt('param_fit_IbataPolysGaiaDR2_to_RARbarions.txt', param_fitted, delimiter=',')


# Test call:
w_0 = np.loadtxt('param_fit_IbataPolysGaiaDR2_to_RARbarions.txt')
#w_0=param_fitted
#w_0=[1.512419743956743332e+02,
#     3.746444750155115599e+01,
#     8.406390055329726607e+00,
#     -6.523565769854224428e+00,
#     -1.090806229835579089e+01,
#     -3.023359902108598973e+01]
#w_0=[1.534699417921158613e+02,
#     3.961154198708851482e+01,
#     8.486608460730758807e+00,
#     -7.002604385415111210e+00,
#     -1.063299397416306213e+01,
#     -4.938322720568865520e+01]
#w_0=[1.548755854008028621e+02,4.100636344130662536e+01,8.482374762996498063e+00,
#	-7.365640413711687096e+00,-1.049256743365175737e+01,-6.229546056474869431e+01]
#w_0=[1.548755854008028621e+02,4.100636344130662536e+01,8.482374762996498063e+00,
#-7.365640413711687096e+00,-1.049256743365175737e+01,-6.229546056474869431e+01]
#w_0=[1.503499419144439742e+02,3.671310321536615362e+01,8.315653523998493668e+00,-6.390434697724216129e+00,-1.106768595825563040e+01,-2.396566624782315813e+01]


print("w_0=",w_0)
phi_1,phi_2,d_hel,mu_ra,mu_dec,v_hel,x,y,z = orbit_model(w_0[0],w_0[1],w_0[2],w_0[3],w_0[4],w_0[5])


# Plot in galactocentric coordinates
#------------------------------------
fig=plt.figure(figsize=(10,10))

plt.scatter(x,y,s=0.1,marker='o',color='red')
plt.scatter(x,z,s=0.1,marker='o',color='blue')
plt.xlim(-15,10)
plt.ylim(-15,20)
plt.grid()
plt.legend()
plt.tight_layout()
plt.show()
fig.savefig("plots/orbit_xyz_fit_my_w0_Ibata2RARbarionic.png")


# Plots in the sky using the GD-1 frame
fig, (ax1, ax2, ax3, ax4, ax5) = plt.subplots(5, 1, sharex=True, figsize=(7, 35))


# Sky position
ax1.set_title('Fitted GD-1 stream (orbit) \n' +
              'in fixed "RAR+barions" potential with Ibata+20 data (Polynomials)')
ax1.scatter(phi_1.wrap_at(180*u.deg), phi_2, s=0.1, marker='o', color='red', label='Fitted orbit')
ax1.plot(Iba_sky['phi_1'], Iba_sky['phi_2'], color='blue', label='Poly (Ibata+2020)')
ax1.set_ylim(-4, 2)
ax1.set_ylabel(r'$\phi_2$ [degrees]')
ax1.legend()

# Heliocentric radial velocity
ax2.scatter(phi_1.wrap_at(180*u.deg), v_hel, s=0.1, marker='o', color='red', label='Fitted orbit')
ax2.plot(Iba_sky['phi_1'], Iba_sky['v_hel'], color='blue', label='Poly (Ibata+2020)')
ax2.set_ylim(-300, 300)
ax2.set_ylabel(r'$v_{\rm{LOS}}$ [km s$^{-1}$]')

# Heliocentric distance
ax3.scatter(phi_1, d_hel, s=0.1, marker='o', color='red', label='Fitted orbit')
ax3.plot(Iba_sky['phi_1'], Iba_sky['d_hel'], color='blue', label='Poly (Ibata+2020)')
ax3.set_ylim(7, 12)
ax3.set_ylabel(r'$D$ [kpc]')

# Proper motion along RA
ax4.scatter(phi_1, mu_ra, s=0.5, color='red', label='Fitted orbit')
ax4.plot(Iba_sky['phi_1'], Iba_sky['mu_ra'], color='blue', label='Poly (Ibata+2020)')
ax4.set_ylabel(r'$\mu_\alpha$ [mas yr$^{-1}$]')

# Proper motion along DEC
ax5.scatter(phi_1, mu_dec, s=0.5, color='red', label='Fitted orbit')
ax5.plot(Iba_sky['phi_1'], Iba_sky['mu_dec'], color='blue', label='Poly (Ibata+2020)')
ax5.set_ylabel(r'$\mu_\delta$ [mas yr$^{-1}$]')

plt.xlabel(r'$\phi_1$ [degrees]')
plt.xlim(IbaPoly.limit[0], IbaPoly.limit[1])
# plt.tight_layout()

plt.show()
fig.savefig("plots/sky_fit_orbit_from_IbataPolysGaiaDR2-data_RARbarionsOrig.png")





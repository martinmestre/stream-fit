# Computation of the orbit model for RAR + barionic component,
# using Koposov+20 data.
# Optimization to find best fit orbit.

from astropy import units as u
from astropy.coordinates import SkyCoord
import astropy.coordinates as coord
from scipy.integrate import solve_ivp
from astropy.io import ascii
from scipy import optimize
from scipy import interpolate
import numpy as np
import scipy.integrate as integrate
from scipy.interpolate import InterpolatedUnivariateSpline
from scipy.interpolate import interp1d
import matplotlib.pyplot as plt
import config as cfg
import accelerations_combine as acco
import GD1Koposov10_class as GD1_class
import model_def

# Load Koposov data
exec(open("./stream_Koposov_data.py").read()) 

# Rar model evaluation
ener_f = 56.0  # keV
param = np.array([ener_f, 3.77780827e+01, 6.63468885e+01, 1.20446329e-05])  # 
r_mw,mass_mw = model_def.model(param)
rho_mw = np.diff(mass_mw)/np.diff(r_mw)/(4.0*np.pi*r_mw[:-1]**2)  # M_sun/pc^3

# Interpolation avoiding NANs
k = np.argwhere(np.isnan(mass_mw))[0][0]
r_sh = r_mw[0:k]
mass_sh = mass_mw[0:k]
cfg.r_max_mw=r_sh[-1]

cfg.mass_spline = InterpolatedUnivariateSpline(r_sh,mass_sh,k=4)  # Allows easy computation of derivatives
def rho_spline(r) :
    deriv= mass_spline.derivative(1)
    return deriv(r)/(4.0*np.pi*r*r)


# Gradient generated by MW's halo
def symp_grad_mw(t, w):
    x=w[0]
    y=w[1]
    z=w[2]
    px=w[3]
    py=w[4]
    pz=w[5]
    r=np.sqrt(x*x+y*y+z*z)
    #print('time=',t)
    return [px,py,pz, acco.accel_mw(x,y,z)[0], acco.accel_mw(x,y,z)[1], acco.accel_mw(x,y,z)[2]]


def grad_mw(x,y,z):
    return -acco.accel_mw(x,y,z)

def rot_vel_mw(r):
    return np.sqrt(r*(grad_mw(r,0,0)[0]))



# The orbit_model here defined works with sky coordinates at input and sky-cartesian at output

# Orbit definition
#-----------------
def orbit_model(alpha,delta,distance,mu_alpha,mu_delta,v_los):
    print('param= ',alpha,delta,distance,mu_alpha,mu_delta,v_los)
    
    # Transformation to galactocentric coordinates
    sky_coord = coord.ICRS(ra=alpha*u.degree, dec=delta*u.degree,
                distance=distance*u.kpc,
                pm_ra_cosdec=mu_alpha*np.cos(delta*u.degree)*u.mas/u.yr,
                pm_dec=mu_delta*u.mas/u.yr,
                radial_velocity=v_los*u.km/u.s)
    galcen_distance = r_sun*u.kpc
    v_sun = coord.CartesianDifferential([11.1, v_circ_sun+12.24, 7.25]*u.km/u.s)
    z_sun=0.0*u.kpc
    frame = coord.Galactocentric(galcen_distance=galcen_distance,
                                galcen_v_sun=v_sun,
                                z_sun=z_sun)
    galac_coord= sky_coord.transform_to(frame)
    
    w_0 = np.zeros(6)
    w_0[:3]=[galac_coord.x/u.kpc,galac_coord.y/u.kpc,galac_coord.z/u.kpc]
    w_0[3:]=[galac_coord.v_x/(u.km/u.s),galac_coord.v_y/(u.km/u.s),galac_coord.v_z/(u.km/u.s)]

    
    # ODE integration
    unit_t = 0.977792221680356   # Gyr
    time_span_s2 = 0.2/unit_t #
    t_0=0.0/unit_t    
    n_steps = 1000
    t_back = np.linspace(t_0,-time_span_s2, n_steps+1)
    t_forw = np.linspace(t_0,time_span_s2, n_steps+1)       
    sol_back = solve_ivp(symp_grad_mw, [t_0,-time_span_s2], w_0, t_eval=t_back,method='DOP853',rtol=5.0e-14,atol=0.5e-14)
    sol_forw = solve_ivp(symp_grad_mw, [t_0,time_span_s2], w_0, t_eval=t_forw,method='DOP853',rtol=5.0e-14,atol=0.5e-14)
    
    t = np.concatenate([sol_back.t,sol_forw.t])
    y = np.concatenate([sol_back.y, sol_forw.y],axis=1)
    y = np.delete(y,0,axis=1) #Remove duplicated column
    
    #Transformation to GD-1 frame of coordinates (\phi_1, \phi_2)
    galac_coord=coord.Galactocentric(x=y[0]*u.kpc,y=y[1]*u.kpc,z=y[2]*u.kpc,
                                     v_x=y[3]*u.km/u.s,v_y=y[4]*u.km/u.s,v_z=y[5]*u.km/u.s,
                           galcen_distance=galcen_distance,galcen_v_sun=v_sun,z_sun=z_sun) 
    gd1_coord = galac_coord.transform_to(GD1_class.GD1Koposov10)
    phi_1 = gd1_coord.phi1
    phi_2 = gd1_coord.phi2
    d_hel = gd1_coord.distance
    v_hel = gd1_coord.radial_velocity
    mu_phi_1 = gd1_coord.pm_phi1_cosphi2/np.cos(phi_2)  #not used by Ibata
    mu_phi_2 = gd1_coord.pm_phi2
    return phi_1, phi_2, d_hel, v_hel, mu_phi_1, mu_phi_2, y[0], y[1], y[2]
    # Transformation to ICRS coordinates      
    #icrs_coord=galac_coord.transform_to(coord.ICRS)
    #mu_ra = icrs_coord.pm_ra_cosdec / np.cos(icrs_coord.dec)
    #mu_dec= icrs_coord.pm_dec
    #return t, phi_1, phi_2, d_hel, v_hel, mu_ra, mu_dec




# Optimization
#--------------------

def chi2(w_0):
    import wrap
    
    phi_1,phi_2,d_hel,v_hel,mu_1,mu_2,x,y,z = orbit_model(w_0[0],w_0[1],w_0[2],w_0[3],w_0[4],w_0[5]) 
    cfg.phi_2_spl = interp1d(phi_1,phi_2,kind='cubic')
    cfg.d_hel_spl = interp1d(phi_1,d_hel,kind='cubic')
    cfg.v_hel_spl = interp1d(phi_1,v_hel,kind='cubic')
    cfg.mu_1_spl  = interp1d(phi_1,mu_1,kind='cubic')
    cfg.mu_2_spl  = interp1d(phi_1,mu_2,kind='cubic')

    cfg.phi_1_min = np.amin(phi_1.value)
    cfg.phi_1_max = np.amax(phi_1.value)
  
    
    sum=np.zeros(5)

    y_mod = wrap.phi_2_wrap(kop_sky['phi1'])
    y_dat = kop_sky['phi2']
    sigma2 = kop_sky['err']**2
    sum[0] = np.sum( (y_dat-y_mod)**2 / sigma2 )

    y_mod = wrap.v_hel_wrap(kop_rv['phi1'])
    y_dat = kop_rv['vr']
    sigma2 = kop_rv['err']**2
    sum[1] = np.sum( (y_dat-y_mod)**2 / sigma2 )
    
    y_mod = wrap.d_hel_wrap(kop_dist['phi1'])
    y_dat = kop_dist['dist']
    sigma2 = kop_dist['err']**2
    sum[2] = np.sum( (y_dat-y_mod)**2 / sigma2 )
    
    y_mod = wrap.mu_1_wrap(kop_pm['phi1'])
    y_dat = kop_pm['mu_phi1']
    sigma2 = kop_pm['err']**2
    sum[3] = np.sum( (y_dat-y_mod)**2 / sigma2 )
    
    y_mod = wrap.mu_2_wrap(kop_pm['phi1'])
    y_dat = kop_pm['mu_phi2']
    sigma2 = kop_pm['err']**2
    sum[4] = np.sum( (y_dat-y_mod)**2 / sigma2 )
    
    print('chi^2 =',np.sum(sum))
    return np.sum(sum)





#w_0=np.array([154.43815737978053, 41.352611518783334, 9.127975838807465, -6.135527680412597, -9.275558167001593, -63.00000001]) 
#w_0= np.array([1.537134289194373480e+02,4.049928742714001118e+01,7.566760255055632101e+00,-6.907681161562341465e+00,-1.086316964958900222e+01,-4.430984948412712754e+01])
#dw = np.abs(w_0)*0.3
#bounds=((w_0[0]-dw[0],w_0[0]+dw[0]), (w_0[1]-dw[1],w_0[1]+dw[1]), (w_0[2]-dw[2],w_0[2]+dw[2]),
#        (w_0[3]-dw[3],w_0[3]+dw[3]), (w_0[4]-dw[4],w_0[4]+dw[4]), (w_0[5]-dw[5],w_0[5]+dw[5]))
bounds =((100,300),(0,90),(4,15),(-50,50),(-50,50),(-300,300) )


r_sun = 8.129
v_circ_sun=rot_vel_mw(r_sun)
print("v_circ_sun=",v_circ_sun)
opt=optimize.differential_evolution(chi2, bounds,strategy='best1bin',maxiter=40,popsize=30,tol=5.0e-8,atol=0.5e-8,disp=True,polish=True,workers=-1)
param_fitted = opt.x
np.savetxt('param_fit_Koposov10_to_RARbarions.txt', param_fitted, delimiter=',')  

w_0=param_fitted
#w_0=np.array([1.559367262212365404e+02,4.244852938178294721e+01,7.808891728113153796e+00,-8.257404940737194110e+00,-1.118645915891409359e+01,-6.129407632055352195e+01])

chi2(w_0)

phi_1,phi_2,d_hel,v_hel,mu_1,mu_2,x,y,z = orbit_model(w_0[0],w_0[1],w_0[2],w_0[3],w_0[4],w_0[5]) 


# Plot in galactocentric coordinates
#------------------------------------
fig=plt.figure(figsize=(10,10))

plt.scatter(x,y,s=0.1,marker='o',color='red')
plt.scatter(x,z,s=0.1,marker='o',color='blue')
plt.xlim(-15,10)
plt.ylim(-15,20)
plt.grid()
plt.legend()
plt.tight_layout()
plt.show()
fig.savefig("plots/orbit_xz_fit_my_w0_Kop2RARbarionic.png")


# Plots in the sky using the GD-1 frame
#---------------------------------------
fig, (ax1,ax2,ax3,ax4) = plt.subplots(4, 1, sharex=True, figsize=(7,20))


# Sky position
ax1.set_title('Koposov+10 data with RAR and barions')
ax1.scatter(phi_1.wrap_at(180*u.deg),phi_2,s=0.1,marker='o', color='red')
ax1.scatter(phi_1,phi_2,s=0.1,marker='o', color='violet')
ax1.errorbar(kop_sky['phi1'], kop_sky['phi2'], yerr=kop_sky['err'], fmt='o', color='cyan', label='Stream\n(Koposov+2010)')
ax1.set_ylim(-4,2)
ax1.set_ylabel(r'$\phi_2$ [degrees]')


# heliocentric radial velocity 
ax2.scatter(phi_1.wrap_at(180*u.deg),v_hel,s=0.1,marker='o', color='red')
ax2.errorbar(kop_rv['phi1'], kop_rv['vr'], yerr=kop_rv['err'], fmt='o', color='cyan', label='Stream\n(Koposov+2010)')
ax2.set_ylim(-400,200)
ax2.set_ylabel(r'$v_{\rm{LOS}}$ [km s$^{-1}$]')

# heliocentric distance
ax3.scatter(phi_1,d_hel,s=0.1,marker='o', color='violet')
ax3.errorbar(kop_dist['phi1'], kop_dist['dist'], yerr=kop_dist['err'], fmt='o', color='cyan', label='Stream\n(Koposov+2010)')
ax3.set_ylim(5,15)
ax3.set_ylabel(r'$d_\odot$ [kpc]')

# proper motion along phi_1 and phi_2
ax4.scatter(phi_1,mu_1,s=0.5, color='violet',label='$\mu_{\phi_1}$')
ax4.scatter(phi_1,mu_2,s=0.5, color='red',label='$\mu_{\phi_2}$')
ax4.errorbar(kop_pm['phi1'], kop_pm['mu_phi1'], yerr=kop_pm['err'], fmt='o', color='blue', label='Stream\n(Koposov+2010)')
ax4.errorbar(kop_pm['phi1'], kop_pm['mu_phi2'], yerr=kop_pm['err'], fmt='o', color='cyan', label='Stream\n(Koposov+2010)')
ax4.set_ylabel('$\mu$ [mas yr$^{-1}$]')
ax4.legend()

#plt.xlim(-80,20)
#plt.grid()
#plt.legend(fontsize='big', handlelength=0.3)
plt.xlabel(r'$\phi_1$ [degrees]')
plt.xlim(-150,100)
#plt.tight_layout()

plt.show()
fig.savefig("plots/sky_fit_Kop2RARbarionic.png")


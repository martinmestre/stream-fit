"""
Fit rotation curve data varying a slice of the RAR's parameter.

Computation of the orbit model for RAR + barionic component.
Using  Sofue+13 rotation curve data.
Optimization to fit the best RAR parameters.

Author: Mart√≠n Mestre.
"""

import numpy as np
import matplotlib.pyplot as plt
import config as cfg
import pandas as pd
import potential_classes as pot
from scipy.integrate import solve_ivp
from scipy import optimize
import vel_Sofue13 as data


def accel_mw(pot_list, x, y, z):
    """Acceleration function generated by the MW total potential."""
    bulge, thin, thick, halo = pot_list
    return bulge.accel(x, y, z)+thin.accel(x, y, z)+thick.accel(x, y, z)+halo.accel(x, y, z)


def symp_grad_mw(t, w, pot_list):
    """Symplectic gradient generated by MW total potential."""
    x = w[0]
    y = w[1]
    z = w[2]
    px = w[3]
    py = w[4]
    pz = w[5]
    acceleration = accel_mw(pot_list, x, y, z)
    return [px, py, pz, acceleration[0], acceleration[1], acceleration[2]]


def grad_mw(pot_list, x, y, z):
    """Minus the acceleration."""
    return -accel_mw(pot_list, x, y, z)


def rot_vel_mw(pot_list, r):
    """Circular velocity."""
    return np.sqrt(r*(grad_mw(pot_list, r, 0, 0)[0]))


def pot_model(ener_f, theta_0, W_0, beta_0):
    """Potential model including barions and dark matter halo."""
    # Set barionic potentials
    M_gal = 2.32e7  # Msun
    bulge = pot.Plummer(460.0*M_gal, 0.3)
    thin = pot.MiyamotoNagai(1700.0*M_gal, 5.3, 0.25)
    thick = pot.MiyamotoNagai(1700.0*M_gal, 2.6, 0.8)
    # Set halo potential
    param = np.array([ener_f, theta_0, W_0, beta_0])
    halo = pot.RAR(param)
    return bulge, thin, thick, halo


def rot_curve_model(pot_list, r):
    """Rotation curve model."""
    bulge, thin, thick, halo = pot_list

    v_circ = np.zeros(len(r))
    for i in range(0, len(r)):
        v_circ[i] = rot_vel_mw(pot_list, r[i])

    return v_circ


def chi2(w_0, ener_f, beta_0, r_data, v_data, dv_data):
    """Chi^2 function."""
    theta_0 = w_0[0]
    d_theta = w_0[1]
    W_0 = theta_0 + d_theta
    pot_list = pot_model(ener_f, theta_0, W_0, beta_0)
    v_mod = rot_curve_model(pot_list, r_data)

    sum = np.sum((v_data-v_mod)**2 / dv_data**2)

    print('chi2=', sum)
    return sum


# Parameters
param_file = 'param_fit_pot-slice_from_Eilers19-data.txt'
ener_f = 56.0  # keV
# d_theta = 28.5751 # this is a fitted parameter.
beta_0 = 1.1977e-5

# Set rotation data from Sofue 2013
r_data = data.v_Sof['r']/1.e3  # now in kpc.
v_data = data.v_Sof['v']
dv_data = data.v_Sof['err_v']

# Set rotation data from Eilers et al. 2019
# v_Eilers = pd.read_csv('vel_Eilers.txt', sep="  ")
# asym_error = [v_Eilers['e_down'], v_Eilers['e_up']]
# dv_data = 0.5*(v_Eilers['e_down']+v_Eilers['e_up'])
# r_data = v_Eilers['r']
# v_data = v_Eilers['v']

# Optimization
bounds = ((35, 41), (25, 31))
opt = optimize.differential_evolution(chi2, bounds, args=(ener_f, beta_0, r_data, v_data, dv_data),
                                      strategy='best2bin', maxiter=40, popsize=40, tol=5.0e-8,
                                      atol=0., disp=True, polish=True, workers=-1)
param_fitted = opt.x
np.savetxt(param_file, param_fitted, delimiter=',')
w_0 = param_fitted
w_0 = np.loadtxt(param_file)

chi2(w_0, ener_f, beta_0, r_data, v_data, dv_data)
theta_0 = w_0[0]
d_theta = w_0[1]
W_0 = theta_0 + d_theta
pot_list = pot_model(ener_f, theta_0, W_0, beta_0)
r = np.logspace(-5, 2, 300)
v_mod = rot_curve_model(pot_list, r)

# Plot in galactocentric coordinates
fig = plt.figure(figsize=(10, 6))

plt.scatter(r, v_mod, s=8, marker='o', color='red', label='Best fit')
plt.errorbar(r_data, v_data, yerr=dv_data, fmt='o', color='cyan', label='Sofue+13')
plt.xlim(0, 40)
plt.ylim(0, 300)
plt.xlabel('r')
plt.ylabel('v_r')
# plt.xscale('symlog')
plt.grid()
plt.legend()
plt.tight_layout()
plt.show()
fig.savefig("plots/orbit_pot-slice_from_Eilers19-data.png")
